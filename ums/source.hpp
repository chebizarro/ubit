/*************************************************************************
 *
 *  umssource.hpp: UMS event sources.
 *  Ubit GUI Toolkit - Version 6.0
 *  (C) 2003-2008 Eric Lecolinet / ENST Paris / www.enst.fr/~elc/ubit
 *
 * ***********************************************************************
 * COPYRIGHT NOTICE : 
 * THIS PROGRAM IS DISTRIBUTED WITHOUT ANY WARRANTY AND WITHOUT EVEN THE 
 * IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. 
 * YOU CAN REDISTRIBUTE IT AND/OR MODIFY IT UNDER THE TERMS OF THE GNU 
 * GENERAL PUBLIC LICENSE AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; 
 * EITHER VERSION 2 OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
 * SEE FILES 'COPYRIGHT' AND 'COPYING' FOR MORE DETAILS.
 * ***********************************************************************/

#ifndef _umssource_hpp_
#define	_umssource_hpp_
#include <vector>

/* ==================================================== ======== ======= */
/** Mouse button mapping
 * specifies the events generated by the buttons of the mouses
 * rule:
 *  source_button_number, source_modifiers ==> flow_button_mask, flow_modifiers
 * see: UMServer::setNativeButtonMapping (for the native mouses)
 * and UMSeventSource::setButtonMapping (for alternate mouses)
 */
struct UMSbutton {
  UMSbutton(int btn_number, unsigned int mod_mask,
	    unsigned int to_btn_mask, unsigned int to_mod_mask);

  // input from the device
  int in_btn_number;
  unsigned int in_mod_mask;     // in_btn_mask not included

  // output to the event flow
  unsigned int out_btn_mask;
  unsigned int out_mod_mask;    // out_btn_mask not included
};

/* ==================================================== ======== ======= */
/**
 * UMS event source.
 */
class EventSource {
public:
  EventSource() {fd = -1;}
  virtual ~EventSource();

  int  filedesc() const {return fd;}
  bool is_open()  const {return fd != -1;}

  virtual bool read() {return false;}
  ///< reads and process incoming data.

  virtual bool canCalibrate() const {return false;}
  virtual void calibrate() {}
  ///< calibrates the device (if this device can be calibrated).

  UMSbutton* getButton(int btn_number);
  UMSbutton* getButton(int btn_number, unsigned int mod_mask);

  void setButton(int btn_number, unsigned int out_btn_mask, unsigned int out_mod_mask);
  void setButton(int btn_number, unsigned int mod_mask, 
		 unsigned int out_btn_mask, unsigned int out_mod_mask);

protected:
  int fd;
  std::vector<UMSbutton*> button_map;
};

#endif
/* ==================================================== [TheEnd] ======= */
